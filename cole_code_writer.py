# === FILE: cole_code_writer.py ===

import os
import json
import time
import shutil
from datetime import datetime
from pathlib import Path
from openai import OpenAI
from assistants.malik import malik_report
from cole_gpt_advisor import ask_gpt  # <-- Merged in

# === Configuration ===
TASK_QUEUE_FILE = "data/autonomy_task_queue.json"
GPT_OUTPUTS_DIR = "cole_generated_code"
STRATEGY_DIR = "strategies"
REPAIR_DIR = "repairs"
CODE_DIR = GPT_OUTPUTS_DIR
INJECT_LOG = "logs/code_writer.log"
CODE_LOG_FILE = "data/cole_code_log.json"
CODE_WRITES_FILE = "data/cole_code_writes.json"

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise ValueError("Missing OPENAI_API_KEY in environment variables.")

client = OpenAI(api_key=OPENAI_API_KEY)

# === Ensure Directories Exist ===
os.makedirs(GPT_OUTPUTS_DIR, exist_ok=True)
os.makedirs("logs", exist_ok=True)
os.makedirs("data", exist_ok=True)

# === Logging Utilities ===
def log_injection(message):
    timestamp = datetime.utcnow().isoformat()
    with open(INJECT_LOG, "a") as f:
        f.write(f"[{timestamp}] {message}\n")

def log_code_write(task, code):
    log_entry = {
        "timestamp": datetime.now().isoformat(),
        "task": task,
        "code": str(code)
    }

    if os.path.exists(CODE_WRITES_FILE):
        with open(CODE_WRITES_FILE, "r") as f:
            logs = json.load(f)
    else:
        logs = []

    logs.append(log_entry)
    with open(CODE_WRITES_FILE, "w") as f:
        json.dump(logs[-500:], f, indent=2)

    print(f"[Code Writer] Logged code write for task: {task}")

# === GPT Code Generator (smart mode) ===
def cole_write_code(task_input):
    """
    Custom hybrid GPT + static fallback.
    """
    # If running handshake test mode:
    if "test" in task_input.lower() and "cole" in task_input.lower() and "gpt" in task_input.lower():
        code = '''# Test strategy generated by Cole-GPT
def run_strategy():
    print("Test Passed: Cole and GPT are working together.")

if __name__ == "__main__":
    run_strategy()
'''
        filename = "test_passed_strategy.py"
        file_path = save_code_to_file(filename, code)
        log_code_write(task_input, code)
        return {
            "file": file_path,
            "code": code
        }

    print(f"[Cole Writer] Generating code for task: {task_input}")
    prompt = f"Write Python code to complete the following task:\n{task_input}"
    response = ask_gpt(prompt)

    safe_name = task_input.replace(" ", "_").replace("/", "_").lower()[:30]
    filename = f"{safe_name}_{datetime.now().strftime('%Y%m%d%H%M%S')}.py"
    file_path = save_code_to_file(filename, response)
    log_code_write(task_input, response)

    return {
        "file": file_path,
        "code": response
    }

# === GPT Code Generator (raw OpenAI fallback) ===
def cole_write_code_gpt(task_description):
    print(f"[Code Writer] Generating code for task: {task_description}")

    prompt = f"""
    You are Cole, an autonomous AI assistant.
    Task: {task_description}

    Write the required Python code to accomplish this task.
    Respond ONLY with the Python code.
    """

    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are a Python code generation assistant."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=700
        )

        code = response.choices[0].message.content.strip()

        if code.startswith("```python"):
            code = code.replace("```python", "").strip()
        if code.endswith("```"):
            code = code[:-3].strip()

        if not isinstance(code, str):
            code = json.dumps(code, indent=2)

        log_code_write(task_description, code)
        print(f"[Code Writer] Code generated for task: {task_description}")
        return code

    except Exception as e:
        print(f"[Code Writer] Error generating code: {e}")
        return f"# Error generating code: {str(e)}"

# === Basic Placeholder Code Generator ===
def generate_basic_code(task_text, code_description):
    timestamp = str(datetime.now())
    file_name = f"{CODE_DIR}/{task_text.replace(' ', '_').replace('/', '_')}_{timestamp.replace(':', '').replace(' ', '_')}.py"

    generated_code = f"""# Auto-generated by Cole on {timestamp}
# Task: {task_text}
# Description: {code_description}

def cole_generated_function():
    print("Executing generated function for: {task_text}")
    return "Task executed: {task_text}"

if __name__ == "__main__":
    cole_generated_function()
"""

    with open(file_name, "w") as f:
        f.write(generated_code)

    log_entry = {
        "timestamp": timestamp,
        "task": task_text,
        "description": code_description,
        "file_created": file_name
    }

    if os.path.exists(CODE_LOG_FILE):
        with open(CODE_LOG_FILE, "r") as f:
            logs = json.load(f)
    else:
        logs = []

    logs.append(log_entry)
    with open(CODE_LOG_FILE, "w") as f:
        json.dump(logs, f, indent=4)

    malik_report(f"Cole generated new code file: {file_name}")
    return file_name

# === API Endpoint Generator ===
def generate_api_endpoint(endpoint_name, method="GET", port=5050):
    code = f"""
from flask import Flask, jsonify

app = Flask(__name__)

@app.route("/api/{endpoint_name.lower()}", methods=["{method}"])
def {endpoint_name.lower()}():
    return jsonify({{"message": "{endpoint_name} triggered successfully."}})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port={port}, debug=True)
"""
    filename = f"cole_generated_api_{endpoint_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.py"
    path = Path(CODE_DIR)
    path.mkdir(exist_ok=True)
    full_path = path / filename
    with open(full_path, "w") as f:
        f.write(code)
    print(f"[COLE GENERATED API]: {full_path}")
    return str(full_path)

# === Save Code to File ===
def save_code_to_file(filename, code):
    os.makedirs(CODE_DIR, exist_ok=True)
    path = os.path.join(CODE_DIR, filename)
    with open(path, "w") as f:
        f.write(code)
    print(f"[CODE SAVED] {path}")
    return path

# === Determine Save Destination Based on Task Type ===
def determine_target_path(task_type, filename):
    if task_type == "strategy":
        os.makedirs(STRATEGY_DIR, exist_ok=True)
        return os.path.join(STRATEGY_DIR, filename)
    elif task_type == "repair":
        os.makedirs(REPAIR_DIR, exist_ok=True)
        return os.path.join(REPAIR_DIR, filename)
    else:
        return os.path.join(GPT_OUTPUTS_DIR, filename)

# === Inject Code Based on Completed Task ===
def inject_code_from_task(task):
    if "result_file" not in task:
        log_injection(f"Skipping task {task.get('id', 'unknown')} — no result file.")
        return

    source_path = os.path.join(GPT_OUTPUTS_DIR, task["result_file"])
    if not os.path.exists(source_path):
        log_injection(f"Missing GPT result file for task {task.get('id', 'unknown')}")
        return

    task_type = task.get("type", "generic")
    target_path = determine_target_path(task_type, task["result_file"])

    if os.path.abspath(source_path) == os.path.abspath(target_path):
        log_injection(f"Skipping injection for {task.get('id', 'unknown')} — source and target are the same.")
        return

    shutil.copyfile(source_path, target_path)
    log_injection(f"Injected {task['result_file']} → {target_path}")

# === Code Writer Master Loop ===
def cole_write_code_main():
    if not os.path.exists(TASK_QUEUE_FILE):
        log_injection("No task queue found.")
        return

    with open(TASK_QUEUE_FILE, "r") as f:
        tasks = json.load(f)

    for task in tasks:
        if task["status"] == "complete" and not task.get("injected"):
            inject_code_from_task(task)
            task["injected"] = True

    with open(TASK_QUEUE_FILE, "w") as f:
        json.dump(tasks, f, indent=2)

    log_injection("Code injection cycle completed.")