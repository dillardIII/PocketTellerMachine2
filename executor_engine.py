# === FILE: executor_engine.py ===
# üß† Task Executor Engine ‚Äì Executes all pending tasks generated by PTM system
# Combines JSON-file task processing and simulated task loop for non-blocking ops

import os
import json
import time
import random
from pathlib import Path

TASKS_DIR = "tasks/pending"
EXECUTED_LOG = "logs/executed_tasks.log"

# Simulated queue fallback (used when file queue is empty)
TASK_QUEUE = [
    "Backtest Strategy",
    "Generate Trade Summary",
    "Trigger Voice Alert",
    "Update Dashboard",
    "Run Chart Analysis",
    "Send Daily Report"
]

def log_execution(task_name):
    Path("logs").mkdir(parents=True, exist_ok=True)
    with open(EXECUTED_LOG, "a", encoding="utf-8") as f:
        f.write(f"{time.ctime()}: Executed {task_name}\n")
    print(f"[Executor] ‚úÖ Executed task: {task_name}")

def execute_task(task_data):
    task_type = task_data.get("type", "unknown")
    content = task_data.get("content", "")
    print(f"[Executor] Running {task_type} task: {content}")
    time.sleep(1)  # Simulate doing work
    return True

def execute_pending_tasks():
    print("[ExecutorEngine] üßÉ Task executor online. Scanning for tasks...")
    Path(TASKS_DIR).mkdir(parents=True, exist_ok=True)

    while True:
        task_files = [f for f in os.listdir(TASKS_DIR) if f.endswith(".json")]

        if task_files:
            for task_file in task_files:
                task_path = os.path.join(TASKS_DIR, task_file)
                try:
                    with open(task_path, "r", encoding="utf-8") as f:
                        task_data = json.load(f)

                    success = execute_task(task_data)
                    if success:
                        log_execution(task_file)
                        os.remove(task_path)
                    else:
                        print(f"[Executor] ‚ùå Failed to execute {task_file}")
                except Exception as e:
                    print(f"[Executor] ‚ùå Error processing {task_file}: {e}")
        else:
            # If no files in queue, run simulated task from fallback
            task = random.choice(TASK_QUEUE)
            print(f"[ExecutorEngine] ‚öôÔ∏è Executing fallback task: {task}")
            time.sleep(random.uniform(2.5, 6))

        time.sleep(3)